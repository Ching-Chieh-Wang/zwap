name=product-mongodb-sink-connector
topics=product-mongodb-write
connector.class=com.mongodb.kafka.connect.MongoSinkConnector
tasks.max=1

connection.uri=${PRODUCT_MONGODB_SERVICE_URI}
database=product
collection=products

# --- Set ID Strategy to BsonOidStrategy for inserts (MongoDB will generate) ---
# This is the default, but explicitly stating it makes intent clear.
# It means the connector itself won't try to derive _id from key/value by default.
document.id.strategy=com.mongodb.kafka.connect.sink.processor.id.strategy.BsonOidStrategy

# --- Configure the DocumentIdAdder Post-Processor to handle _id from VALUE for updates ---
# This handles the case where _id is provided in the VALUE for updates/upserts.
post.processor.chain=com.mongodb.kafka.connect.sink.processor.DocumentIdAdder
value.projection.type=ALLOWLIST
value.projection.list=_id

# --- Write Model Strategy for Upserts ---
write.strategy=com.mongodb.kafka.connect.sink.writemodel.strategy.UpdateOneDefaultStrategy

# --- Handle Deletes using a SINK Record Transformer (SMT) ---
# You CANNOT use delete.on.null.values=true with BsonOidStrategy.
# Instead, use an SMT to convert delete messages into a format the connector understands for deletion.
# The Delete.TopicSmt is good for this, converting tombstone messages (key present, value null)
# into a special SMT record format that triggers a delete.
transforms=InsertDelete
transforms.InsertDelete.type=com.mongodb.kafka.connect.sink.converters.DeleteTopicSmt$Value
transforms.InsertDelete.delete.tombstone.enabled=true # Required for tombstone deletes

max.batch.size=500
errors.tolerance=all
errors.log.enable=true
errors.log.include.messages=true