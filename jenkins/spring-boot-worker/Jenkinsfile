pipeline {
    agent any

    environment {
        REPO_URL = 'https://github.com/Ching-Chieh-Wang/zwap.git'
        VAULT_SERVICE_URI = 'http://linux-076:50006'
        KAFKA_CONNECTOR_URI = 'http://linux-084:50001'
    }


    triggers {
        GenericTrigger(
            token: 'xiuxiulovejingjie',

            genericVariables: [
                [
                    key: 'changed_files',
                    value: '$.commits[*].[\'modified\',\'added\',\'removed\'][*]',
                    expressionType: 'JSONPath'
                ]
            ],

            // This replaces the 'regexpFilter' block.
            // Text and expression are direct parameters.
            regexpFilterText: '$changed_files',
            regexpFilterExpression: "(?s).*${env.JOB_NAME.split('/').last()}.*",

            printContributedVariables: false,
            printPostContent: false


        )
    }

    stages {
            stage('Cleanup') {
                steps {
                    cleanWs()
                }
            }

            stage('Clone') {
                steps {
                    script {
                        def service = env.JOB_NAME.split("/").last()
                        echo "Cloning service: ${service}"
                        sh """
                            set -e
                            mkdir -p ~/zwap
                            cd ~/zwap

                            if [ ! -d ".git" ]; then
                                git init -b main
                                git remote add origin "${REPO_URL}"
                                git config core.sparseCheckout true
                                git sparse-checkout init --no-cone
                                git sparse-checkout set ${service} jenkins
                                git pull origin main
                            else
                                git fetch origin
                                git reset --hard origin/main
                            fi
                        """
                    }
                }
            }

            stage('Read Deploy Config') {
                steps {
                    script {
                        def deployConfig = readYaml(file: '~/zwap/jenkins/deploy-config.yaml')
                        env.DEPLOY_CONFIG = groovy.json.JsonOutput.toJson(deployConfig)
                    }
                }
            }

            stage('Build') {
                steps {
                    script {
                        def service = env.JOB_NAME.split("/").last()
                        echo "Building service: ${service}"
                        sh "mvn clean package -DskipTests -f ${service}/pom.xml"
                        sh """
                            mkdir -p ~/zwap/${service}
                            mv ${service}/target/${service}*.jar ~/zwap/${service}/${service}.jar
                        """
                    }
                }
            }

            stage('Deploy') {
                steps {
                    script {
                        def service = env.JOB_NAME.split("/").last()
                        def deployConfig = new groovy.json.JsonSlurperClassic().parseText(env.DEPLOY_CONFIG)

                        def server = deployConfig[service]?.server
                        def port = deployConfig[service]?.port
                        if (server && port) {
                            sshagent(credentials: ['ssh-deploy']) {
                                sshCommand remote: [name: service, host: server, port: port.toInteger(), user: 'jenkins', credentialsId: 'ssh-deploy'], command: '''
                                    pkill -f "${service}.jar" || true
                                    nohup java -jar ~/zwap/${service}/${service}.jar > ~/zwap/${service}/app.log 2>&1 &
                                '''
                            }
                        } else {
                            echo "No deployment configuration found for service: ${service}"
                        }
                    }
                }
            }

    }
//     post {
//         always {
//             cleanWs()
//             echo 'Workspace cleaned up after pipeline run.'
//         }
//     }
}
