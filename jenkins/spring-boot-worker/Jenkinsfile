pipeline {
    agent any

    environment {
        SSH_KEY = 'linux-server'
        REPO_URL = 'https://github.com/Ching-Chieh-Wang/zwap.git'
        VAULT_SERVICE_URI = 'http://linux-076:50006'
        KAFKA_CONNECTOR_URI = 'http://linux-084:50001'
    }


    triggers {
        GenericTrigger(
            token: 'xiuxiulovejingjie',

            genericVariables: [
                [
                    key: 'changed_files',
                    value: '$.commits[*].[\'modified\',\'added\',\'removed\'][*]',
                    expressionType: 'JSONPath'
                ]
            ],

            // This replaces the 'regexpFilter' block.
            // Text and expression are direct parameters.
            regexpFilterText: '$changed_files',
            regexpFilterExpression: "(?s).*${env.JOB_NAME.split('/').last()}.*",

            printContributedVariables: false,
            printPostContent: false


        )
    }

    stages {
            stage('Cleanup') {
                steps {
                    cleanWs()
                }
            }

            stage('Clone') {
                steps {
                    script {
                        echo "Cloning repo"
                        sh """
                            set -e

                            if [ ! -d "${HOME}/zwap/.git" ]; then
                                rm -rf ${HOME}/zwap
                                git clone --branch main ${REPO_URL} ${HOME}/zwap
                            else
                                cd ${HOME}/zwap
                                git fetch origin
                                git reset --hard origin/main
                            fi
                        """
                    }
                }
            }

            stage('Read Deploy Config') {
                steps {
                    script {
                        def deployConfig = readYaml(file: "${env.HOME}/zwap/jenkins/deploy-config.yaml")
                        env.DEPLOY_CONFIG = groovy.json.JsonOutput.toJson(deployConfig)
                    }
                }
            }

            stage('Mint Vault Token') {
                steps {
                    build job: 'vault-token-worker',
                          parameters: [string(name: 'SERVICE', value: env.JOB_NAME.split("/").last())],
                          wait: true
                }
            }

            stage('Build') {
                steps {
                    script {
                        def service = env.JOB_NAME.split("/").last()
                        echo "Building service: ${service}"
                        sh "mvn clean package spring-boot:repackage -DskipTests -am -f ${env.HOME}/zwap/${service}/pom.xml"
                        sh """
                            mkdir -p ${env.HOME}/zwap/${service}
                            mv ${env.HOME}/zwap/${service}/target/${service}-*.jar ${env.HOME}/zwap/${service}/${service}.jar
                        """
                    }
                }
            }

            stage('Deploy') {
                steps {
                    script {
                        def service = env.JOB_NAME.split("/").last()
                        def deployConfig = new groovy.json.JsonSlurperClassic().parseText(env.DEPLOY_CONFIG)

                        def host = deployConfig[service]?.host
                        def port = deployConfig[service]?.port
                        if (host && port) {
                            // Securely inject the token minted by vault-token-worker
                            def normalizedService = service.toUpperCase().replace('-', '_')
                            def vaultEnvVar = "VAULT_${normalizedService}_TOKEN"

                            withCredentials([string(credentialsId: vaultEnvVar, variable: 'VAULT_TOKEN')]) {
                                sshagent(credentials: [SSH_KEY]) {
                                    sh """
                                        ssh -o StrictHostKeyChecking=no ${host} \\
                                          "set -e
                                           mkdir -p ~/logs ~/pids
                                           if [ -f ~/pids/${service}.pid ]; then
                                             oldpid=\\\$(cat ~/pids/${service}.pid)
                                             kill -9 \\\$oldpid || true
                                             rm -f ~/pids/${service}.pid
                                             rm -f ~/logs/${service}.log
                                           fi
                                           echo '[DEBUG] Injecting ${vaultEnvVar}: \${VAULT_TOKEN:0:5}...'
                                           export ${vaultEnvVar}='\$VAULT_TOKEN'
                                           VAULT_CONFIG_SERVICE_TOKEN=$VAULT_TOKEN nohup java -jar ~/zwap/${service}/${service}.jar > ~/logs/${service}.log 2>&1 &
                                           pid=\\\$!
                                           echo \\\$pid > ~/pids/${service}.pid
                                           echo '[Deploy] Started ${service} with PID' \\\$pid"
                                    """
                                }
                            }
                        } else {
                            error("No deployment configuration found for service: ${service}")
                        }
                    }
                }
            }

            stage('Health Check') {
                steps {
                    script {
                        def service = env.JOB_NAME.split("/").last()
                        def deployConfig = new groovy.json.JsonSlurperClassic().parseText(env.DEPLOY_CONFIG)

                        def host = deployConfig[service]?.host
                        def port = deployConfig[service]?.port
                        if (host && port) {
                            sh """
                                sleep 15
                                curl -f http://${host}:${port}/actuator/health
                            """
                        } else {
                            error("No deployment configuration found for service: ${service}")
                        }
                    }
                }
                post {
                    failure {
                        script {
                            def service = env.JOB_NAME.split("/").last()
                            def deployConfig = new groovy.json.JsonSlurperClassic().parseText(env.DEPLOY_CONFIG)
                            def host = deployConfig[service]?.host
                            if (host) {
                                sshagent(credentials: [SSH_KEY]) {
                                    sh "ssh -o StrictHostKeyChecking=no ${host} 'cat ~/logs/${service}.log || true'"
                                }
                            }
                            error("Health check failed for ${service}")
                        }
                    }
                }
            }

    }
    post {
        always {
            cleanWs()
            echo 'Workspace cleaned up after pipeline run.'
        }
    }
}
